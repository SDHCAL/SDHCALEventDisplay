/*
 *
 * sdhcal_event_display.cc main file template automatically generated by a class generator
 * Creation date : sam. avr. 26 2014
 *
 * This file is part of SDHCALEventDisplay libraries.
 * 
 * SDHCALEventDisplay is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * SDHCALEventDisplay is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with SDHCALEventDisplay.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// root
#include "TEveManager.h"
#include "TRint.h"
#include "TSystem.h"
#include "TGLViewer.h"
#include "TGeoManager.h"

// sdhcal
#include "Gui.h"
#include "SDHCALEventDisplayVersion.h"
#include "Config.h"
#include "EventNavigator.h"

// streamlog
#include "streamlog/streamlog.h"

// tclap
#include "tclap/CmdLine.h"
#include "tclap/Arg.h"

// std
#include <string>
#include <ctime>

extern TGeoManager *gGeoManager;

using namespace streamlog;
using namespace sdhcal;

int main(int argc, char **argv)
{

	time_t now = time(0);

	std::cout << "*********************************************" << std::endl;
	std::cout << "*                                            " << std::endl;
	std::cout << "*      WELCOME to SDHCAL Event Display       " << std::endl;
	std::cout << "*              Copyright 2014                " << std::endl;
	std::cout << "*            Version " << SDHCALEventDisplay_VERSION << ""<< std::endl;
	std::cout << "*         Started at " << ctime( & now );
	std::cout << "*" << std::endl;
	std::cout << "*         sdhcal_event_display binary        " << std::endl;
	std::cout << "*               Author : R. Ete              " << std::endl;
	std::cout << "*********************************************" << std::endl;

	std::string cmdLineFooter = "Please report bug to <rete@ipnl.in2p3.fr>";
	TCLAP::CmdLine *pCommandLine = new TCLAP::CmdLine(cmdLineFooter, ' ', SDHCALEventDisplay_VERSION);

	// gear file
	TCLAP::ValueArg<std::string> gearFileNameArg(
					"g"
			, "gear-file"
			, "The gear file name for geometry"
			, true
			, ""
			, "string");
	pCommandLine->add(gearFileNameArg);

	// lcio file name (optional)
	TCLAP::ValueArg<std::string> lcioFileNameArg(
					"f"
			, "lcio-file"
			, "The lcio file name for data"
			, false
			, ""
			, "string");
	pCommandLine->add(lcioFileNameArg);

	// verbose level (optional)
	std::vector<std::string> verboseAllowedValues;
	verboseAllowedValues.push_back("DEBUG");
	verboseAllowedValues.push_back("MESSAGE");
	verboseAllowedValues.push_back("WARNING");
	verboseAllowedValues.push_back("ERROR");
	TCLAP::ValuesConstraint<std::string> verboseConstraint(verboseAllowedValues);
	TCLAP::ValueArg<std::string> verboseLevelArg(
					"v"
			, "verbose"
			, "The verbose level in terminal"
			, false
			, "MESSAGE"
			, &verboseConstraint);
	pCommandLine->add(verboseLevelArg);

	pCommandLine->parse(argc, argv);

	// logstream settings
	streamlog::out.init(std::cout, "SDHCALEventDisplay");

 streamlog::out.addLevelName<streamlog::DEBUG>();
 streamlog::out.addLevelName<streamlog::MESSAGE>();
 streamlog::out.addLevelName<streamlog::WARNING>();
 streamlog::out.addLevelName<streamlog::ERROR>();

 streamlog::logscope scope(streamlog::out);

 scope.setLevel(verboseLevelArg.getValue());

 Config *pConfig = Config::getInstance();
 pConfig->parseGearFile(gearFileNameArg.getValue());

	// application main thread
	TRint *pApplication = new TRint("SDHCAL Event display application", 0, 0);

	// Graphical User Interface
	// Contains TEveManager::Create() and additional gui implementation
	Gui *pGui = Gui::getInstance();
	pGui->build();

	if(lcioFileNameArg.isSet())
	{
		pGui->getEventNavigator()->loadLCIOFile(lcioFileNameArg.getValue());
	}

	pApplication->Run();

	delete pApplication;

	return 0;
}


