/*
 *
 * CaloHitFrame.cc source template automatically generated by a class generator
 * Creation date : lun. mai 5 2014
 *
 * This file is part of SDHCALEventDisplay libraries.
 * 
 * SDHCALEventDisplay is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * SDHCALEventDisplay is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with SDHCALEventDisplay.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "CaloHitFrame.h"

#include "SDHCAL.h"
#include "GeometryManager.h"
#include "EventManager.h"
#include "Gui.h"
#include "CaloHit.h"
#include "Typedef.h"

#include "TGFrame.h"
#include "TGButtonGroup.h"
#include "TGButton.h"
#include "TGNumberEntry.h"
#include "TGLabel.h"
#include "TEveManager.h"
#include "TGComboBox.h"
#include "TStyle.h"
#include "TColor.h"

// streamlog
#include "streamlog/streamlog.h"

ClassImpQ(sdhcal::CaloHitFrame);

namespace sdhcal
{

CaloHitFrame::CaloHitFrame(TGCompositeFrame *pMainFrame)
{
	m_pSDHCAL = Gui::getInstance()->getGeometryManager()->getSDHCAL();
	EventManager *pEventManager = Gui::getInstance()->getEventManager();

	m_pCaloHitFrame = new TGGroupFrame(pMainFrame, "Calo hits", kVerticalFrame);
	pMainFrame->AddFrame(m_pCaloHitFrame, new TGLayoutHints(kLHintsNormal | kLHintsExpandX));

	m_pCaloHitColorFrame = new TGHorizontalFrame(m_pCaloHitFrame);
	m_pCaloHitFrame->AddFrame(m_pCaloHitColorFrame, new TGLayoutHints(kLHintsNormal, 0, 0, 2));

	m_pCaloHitColorLabel = new TGLabel(m_pCaloHitColorFrame, "Calo hit color");
	m_pCaloHitColorFrame->AddFrame(m_pCaloHitColorLabel);

	m_pCaloHitColorComboBox = new TGComboBox(m_pCaloHitColorFrame);
	m_pCaloHitColorFrame->AddFrame(m_pCaloHitColorComboBox, new TGLayoutHints(kLHintsLeft | kLHintsCenterY, 6));
	m_pCaloHitColorComboBox->AddEntry("Threshold", CaloHitFrame::THRESHOLD_COLOR);
	m_pCaloHitColorComboBox->AddEntry("Density 2D", CaloHitFrame::DENSITY_2D_COLOR);
	m_pCaloHitColorComboBox->AddEntry("Density 3D", CaloHitFrame::DENSITY_3D_COLOR);
//	m_pCaloHitColorComboBox->AddEntry("Energy profile", CaloHitFrame::ENERGY_PROFILE_COLOR); // not yet supported
	m_pCaloHitColorComboBox->Select(CaloHitFrame::THRESHOLD_COLOR);
	m_pCaloHitColorComboBox->Resize(100, 20);

 m_pShowCaloHitsButton = new TGCheckButton(m_pCaloHitFrame, new TGHotString("Show calo hits"));
 m_pShowCaloHitsButton->SetState(kButtonDown, false);
 m_pCaloHitFrame->AddFrame(m_pShowCaloHitsButton);

 m_pShowPartialButton = new TGCheckButton(m_pCaloHitFrame, new TGHotString("Show partially :"));
 m_pCaloHitFrame->AddFrame(m_pShowPartialButton);

 m_pShowPartialCaloHitsFrame = new TGVerticalFrame(m_pCaloHitFrame);
 m_pCaloHitFrame->AddFrame(m_pShowPartialCaloHitsFrame);

 m_pShowHideButtonGroup = new TGHButtonGroup(m_pShowPartialCaloHitsFrame);
 m_pShowButton = new TGRadioButton(m_pShowHideButtonGroup, new TGHotString("Show"), 1);
 m_pHideButton = new TGRadioButton(m_pShowHideButtonGroup, new TGHotString("Hide"), 2);
 m_pShowHideButtonGroup->SetLayoutHints(new TGLayoutHints(kLHintsCenterX & kLHintsCenterY));
 m_pShowHideButtonGroup->Show();
 m_pShowButton->SetOn();
 m_pShowHideButtonGroup->SetRadioButtonExclusive(true);

 m_pShowPartialCaloHitsFrame->AddFrame(m_pShowHideButtonGroup, new TGLayoutHints(kLHintsCenterX | kLHintsTop));

 m_pFromLayerFrame = new TGHorizontalFrame(m_pShowPartialCaloHitsFrame);
 m_pShowPartialCaloHitsFrame->AddFrame(m_pFromLayerFrame, new TGLayoutHints(kLHintsCenterX | kLHintsTop));
 m_pToLayerFrame = new TGHorizontalFrame(m_pShowPartialCaloHitsFrame);
  m_pShowPartialCaloHitsFrame->AddFrame(m_pToLayerFrame, new TGLayoutHints(kLHintsCenterX | kLHintsTop));

	m_pFromLayerLabel = new TGLabel(m_pFromLayerFrame, "from layer");
	m_pFromLayerEntry = new TGNumberEntry(m_pFromLayerFrame, 0, 5, -1,
			TGNumberFormat::kNESInteger, TGNumberFormat::kNEANonNegative, TGNumberFormat::kNELLimitMax,
			0, m_pSDHCAL->getNumberOfLayers()-1);

 m_pToLayerLabel = new TGLabel(m_pToLayerFrame, "to layer");
	m_pToLayerEntry = new TGNumberEntry(m_pToLayerFrame, m_pSDHCAL->getNumberOfLayers()-1, 5, -1,
			TGNumberFormat::kNESInteger, TGNumberFormat::kNEANonNegative, TGNumberFormat::kNELLimitMax,
			0, m_pSDHCAL->getNumberOfLayers()-1);

	m_pFromLayerFrame->AddFrame(m_pFromLayerLabel, new TGLayoutHints(kLHintsCenterY, 0, 4));
	m_pFromLayerFrame->AddFrame(m_pFromLayerEntry, new TGLayoutHints(kLHintsCenterY, 0, 4));
	m_pToLayerFrame->AddFrame(m_pToLayerLabel, new TGLayoutHints(kLHintsCenterY, 5, 4));
	m_pToLayerFrame->AddFrame(m_pToLayerEntry, new TGLayoutHints(kLHintsCenterY, 7, 4));

	m_pCaloHitCutFrame = new TGGroupFrame(m_pCaloHitFrame, "Cut value", kVerticalFrame);
	m_pCaloHitFrame->AddFrame(m_pCaloHitCutFrame, new TGLayoutHints(kLHintsCenterY, 0, 0, 4));

 m_pCaloHitCutButton = new TGCheckButton(m_pCaloHitCutFrame, "Apply cut");
 m_pCaloHitCutButton->Toggled(false);
 m_pCaloHitCutFrame->AddFrame(m_pCaloHitCutButton, new TGLayoutHints(kLHintsCenterY, 0, 4, 4));

 m_pCutOnLabel = new TGLabel(m_pCaloHitCutFrame, "Cut on");
 m_pCaloHitCutFrame->AddFrame(m_pCutOnLabel, new TGLayoutHints(kLHintsCenterY));

	m_pCaloHitCutComboBox = new TGComboBox(m_pCaloHitCutFrame);
	m_pCaloHitCutComboBox->AddEntry("Threshold 1 only", CaloHitFrame::THRESHOLD_1_ONLY_CUT);
	m_pCaloHitCutComboBox->AddEntry("Threshold 2 only", CaloHitFrame::THRESHOLD_2_ONLY_CUT);
	m_pCaloHitCutComboBox->AddEntry("Threshold 3 only", CaloHitFrame::THRESHOLD_3_ONLY_CUT);
	m_pCaloHitCutComboBox->AddEntry("Threshold 1 and 2", CaloHitFrame::THRESHOLD_1_AND_2_CUT);
	m_pCaloHitCutComboBox->AddEntry("Threshold 1 and 3", CaloHitFrame::THRESHOLD_1_AND_3_CUT);
	m_pCaloHitCutComboBox->AddEntry("Threshold 2 and 3", CaloHitFrame::THRESHOLD_2_AND_3_CUT);
	m_pCaloHitCutComboBox->AddEntry("Density 2D greater than", CaloHitFrame::DENSITY_2D_GREATER);
	m_pCaloHitCutComboBox->AddEntry("Density 2D lesser than", CaloHitFrame::DENSITY_2D_LESSER);
	m_pCaloHitCutComboBox->AddEntry("Density 3D greater than", CaloHitFrame::DENSITY_3D_GREATER);
	m_pCaloHitCutComboBox->AddEntry("Density 3D lesser than", CaloHitFrame::DENSITY_3D_LESSER);
	m_pCaloHitCutComboBox->Select(CaloHitFrame::THRESHOLD_1_ONLY_CUT);
	m_pCaloHitCutComboBox->Resize(160, 20);
	m_pCaloHitCutFrame->AddFrame(m_pCaloHitCutComboBox);

	m_pCutValueLabel = new TGLabel(m_pCaloHitCutFrame, "value");
	m_pCaloHitCutFrame->AddFrame(m_pCutValueLabel, new TGLayoutHints(kLHintsCenterY));
	m_pCutValueEntryField = new TGNumberEntryField(m_pCaloHitCutFrame);
	m_pCaloHitCutFrame->AddFrame(m_pCutValueEntryField);

	// signal - slot connections
	pEventManager->Connect("caloHitsAvailable()", "sdhcal::CaloHitFrame", this, "getCurrentOrderedCaloHitList()");
	m_pCaloHitColorComboBox->Connect("Selected(Int_t)", "sdhcal::CaloHitFrame", this, "changeCaloHitsColors(Int_t)");
	m_pShowCaloHitsButton->Connect("Toggled(Bool_t)", "sdhcal::CaloHitFrame", this, "showCaloHits(Bool_t)");

	m_pShowPartialButton->Connect("Toggled(Bool_t)", "sdhcal::CaloHitFrame", this, "enableShowPartiallyCaloHitFrame(Bool_t)");
 m_pShowPartialButton->Toggled(false);
 m_pFromLayerEntry->Connect("ValueSet(Long_t)", "sdhcal::CaloHitFrame", this, "updateCaloHits()");
 m_pToLayerEntry->Connect("ValueSet(Long_t)", "sdhcal::CaloHitFrame", this, "updateCaloHits()");
 m_pShowButton->Connect("Toggled(Bool_t)", "sdhcal::CaloHitFrame", this, "updateCaloHits()");
 m_pHideButton->Connect("Toggled(Bool_t)", "sdhcal::CaloHitFrame", this, "updateCaloHits()");

 m_pCaloHitCutButton->Connect("Toggled(Bool_t)", "sdhcal::CaloHitFrame", this, "enableCutValueFrame(Bool_t)");
 m_pCaloHitCutButton->Toggled(false);

 m_pCaloHitCutComboBox->Connect("Selected(Int_t)", "sdhcal::CaloHitFrame", this, "updateCaloHits()");
 m_pCutValueEntryField->Connect("ProcessedEvent(Event_t*)", "sdhcal::CaloHitFrame", this, "updateCaloHits()");

 const Int_t NRGBs = 5;
 const Int_t NCont = 256;
 Double_t stops[NRGBs] = { 0.00, 0.30, 0.61, 0.84, 1.00 };
 Double_t red[NRGBs] = { 0.00, 0.00, 0.57, 0.90, 0.51 };
 Double_t green[NRGBs] = { 0.00, 0.65, 0.95, 0.20, 0.00 };
 Double_t blue[NRGBs] = { 0.51, 0.55, 0.15, 0.00, 0.10 };

 TColor::CreateGradientColorTable(NRGBs, stops, red, green, blue,NCont);
 gStyle->SetNumberContours(NCont);
}

CaloHitFrame::~CaloHitFrame() 
{

}


void CaloHitFrame::getCurrentOrderedCaloHitList()
{
	m_currentOrderedCaloHitList = Gui::getInstance()->getEventManager()->getCurrentOrderedCaloHitList();

	this->updateCaloHits();
	this->changeCaloHitsColors(m_pCaloHitColorComboBox->GetSelected());
}


void CaloHitFrame::enableShowPartiallyCaloHitFrame(Bool_t on)
{
	m_pFromLayerLabel->Disable(!on);
	m_pFromLayerEntry->SetState(on);
	m_pToLayerLabel->Disable(!on);
	m_pToLayerEntry->SetState(on);
	m_pShowButton->SetEnabled(on);
	m_pHideButton->SetEnabled(on);

	this->showPartiallyCaloHits(on);
}


void CaloHitFrame::enableCutValueFrame(Bool_t on)
{
	m_pCutOnLabel->Disable(!on);
	m_pCaloHitCutComboBox->SetEnabled(on);
	m_pCutValueLabel->Disable(!on);
	m_pCutValueEntryField->SetEnabled(on);

	this->updateCaloHits();
}


void CaloHitFrame::showPartiallyCaloHits(Bool_t on)
{
	if(on)
	{
		if(!m_pShowCaloHitsButton->IsDown())
			return;

		this->updateCaloHits();
	}
	else
	{
		this->showCaloHits(m_pShowCaloHitsButton->IsDown());
	}
}



void CaloHitFrame::showCaloHits(Bool_t on)
{

	if(m_currentOrderedCaloHitList.empty())
		return;

	if(on)
	{
		m_currentOrderedCaloHitList.show();
	}
	else
	{
		m_currentOrderedCaloHitList.hide();
	}

	gEve->FullRedraw3D();
}



void CaloHitFrame::updateCaloHits()
{
	if(!m_pShowCaloHitsButton->IsDown())
	{
		m_currentOrderedCaloHitList.hide();
		gEve->FullRedraw3D();
		return;
	}

	// loop over calo hit in order to hide some of them
	for(OrderedCaloHitList::iterator layerIter = m_currentOrderedCaloHitList.begin() , layerEndIter = m_currentOrderedCaloHitList.end() ;
			layerEndIter != layerIter ; ++layerIter)
	{
		for(CaloHitList::iterator iter = layerIter->second.begin() , endIter = layerIter->second.end() ; endIter != iter ; ++iter)
		{
			CaloHit *pCaloHit = *iter;

			bool shouldHideCaloHit = this->shouldHideCaloHit(pCaloHit);

			if(shouldHideCaloHit)
				pCaloHit->hide();
			else
				pCaloHit->show();
		}
	}

	gEve->FullRedraw3D();
}


bool CaloHitFrame::shouldHideCaloHit(CaloHit *pCaloHit)
{
	const unsigned int fromLayer = m_pFromLayerEntry->GetNumber();
	const unsigned int toLayer   = m_pToLayerEntry->GetNumber();

	const unsigned int minLayer = m_pFromLayerEntry->GetNumMin();
	const unsigned int maxLayer = m_pToLayerEntry->GetNumMax();

	const unsigned int currentLayer = pCaloHit->getCell().m_layer;

	// check if layer should be hidden or not
	if(m_pShowPartialButton->IsDown())
	{
		if(fromLayer > toLayer)
			return true;

		if(m_pShowButton->IsDown())
		{
			if(fromLayer == minLayer && toLayer == maxLayer)
				return false;

			if(currentLayer >= fromLayer && currentLayer <= toLayer)
				return false;
			else
				return true;
		}
		else
		{
			if(fromLayer == minLayer && toLayer == maxLayer)
				return true;

			if(currentLayer >= fromLayer && currentLayer <= toLayer)
				return true;
			else
				return false;
		}
	}

	// check for calo hit cut value
	double cutValue = 0.0;
	CaloHitFrame::CaloHitCut caloHitCut;

	if(m_pCaloHitCutButton->IsDown())
	{
		caloHitCut = static_cast<CaloHitFrame::CaloHitCut>(m_pCaloHitCutComboBox->GetSelected());
		cutValue = m_pCutValueEntryField->GetNumber();
	}
	else
		return false;

	switch(caloHitCut)
	{
	 case THRESHOLD_1_ONLY_CUT:
	 {
	 	if(THRESHOLD_1 == pCaloHit->getSemiDigitalThreshold())
	 		return false;
	 	else
	 		return true;
	 }
	 case THRESHOLD_2_ONLY_CUT:
	 {
	 	if(THRESHOLD_2 == pCaloHit->getSemiDigitalThreshold())
	 		return false;
	 	else
	 		return true;
	 }
	 case THRESHOLD_3_ONLY_CUT:
	 {
	 	if(THRESHOLD_3 == pCaloHit->getSemiDigitalThreshold())
	 		return false;
	 	else
	 		return true;
	 }
	 case THRESHOLD_1_AND_2_CUT:
	 {
	 	if(THRESHOLD_1 == pCaloHit->getSemiDigitalThreshold() || THRESHOLD_2 == pCaloHit->getSemiDigitalThreshold())
	 		return false;
	 	else
	 		return true;
	 }
	 case THRESHOLD_1_AND_3_CUT:
	 {
	 	if(THRESHOLD_1 == pCaloHit->getSemiDigitalThreshold() || THRESHOLD_3 == pCaloHit->getSemiDigitalThreshold())
	 		return false;
	 	else
	 		return true;
	 }
	 case THRESHOLD_2_AND_3_CUT:
	 {
	 	if(THRESHOLD_2 == pCaloHit->getSemiDigitalThreshold() || THRESHOLD_3 == pCaloHit->getSemiDigitalThreshold())
	 		return false;
	 	else
	 		return true;
	 }
	 case DENSITY_2D_GREATER:
	 {
	 	if(cutValue < pCaloHit->getDensity2D())
	 		return false;
	 	else
	 		return true;
	 }
	 case DENSITY_2D_LESSER:
	 {
	 	if(cutValue > pCaloHit->getDensity2D())
	 		return false;
	 	else
	 		return true;
	 }
	 case DENSITY_3D_GREATER:
	 {
	 	if(cutValue < pCaloHit->getDensity3D())
	 		return false;
	 	else
	 		return true;
	 }
	 case DENSITY_3D_LESSER:
	 {
	 	if(cutValue > pCaloHit->getDensity3D())
	 		return false;
	 	else
	 		return true;
	 }
	 default:
	 	return false;
	}

	return false;
}



void CaloHitFrame::changeCaloHitsColors(Int_t entry)
{

	for(OrderedCaloHitList::iterator layerIter = m_currentOrderedCaloHitList.begin() , layerEndIter = m_currentOrderedCaloHitList.end() ;
			layerEndIter != layerIter ; ++layerIter)
	{
		for(CaloHitList::iterator iter = layerIter->second.begin() , endIter = layerIter->second.end() ; endIter != iter ; ++iter)
		{
			CaloHit *pCaloHit = *iter;
			this->setCaloHitColor(pCaloHit, static_cast<CaloHitColor>(entry));
		}
	}

	gEve->FullRedraw3D();
}

void CaloHitFrame::setCaloHitColor(CaloHit *pCaloHit, CaloHitColor caloHitColor)
{

	switch(caloHitColor)
	{
		case THRESHOLD_COLOR:
		{
			SemiDigitalThreshold semiDigitalThreshold =  pCaloHit->getSemiDigitalThreshold();

			if(THRESHOLD_1 == semiDigitalThreshold)
				pCaloHit->setColor(kGreen);
			else if(THRESHOLD_2 == semiDigitalThreshold)
				pCaloHit->setColor(kBlue);
			else
				pCaloHit->setColor(kRed);

			return;
		}
		case DENSITY_2D_COLOR:
		{
			pCaloHit->setColor(CaloHitFrame::getColorBetweenMinAndMax(0.f, 1.f, pCaloHit->getDensity2D()));
			return;
		}
		case DENSITY_3D_COLOR:
		{
			pCaloHit->setColor(CaloHitFrame::getColorBetweenMinAndMax(0.f, 1.f, pCaloHit->getDensity3D()));
			return;
		}
		default:
		{
			SemiDigitalThreshold semiDigitalThreshold =  pCaloHit->getSemiDigitalThreshold();

			if(THRESHOLD_1 == semiDigitalThreshold)
				pCaloHit->setColor(kGreen);
			else if(THRESHOLD_2 == semiDigitalThreshold)
				pCaloHit->setColor(kBlue);
			else
				pCaloHit->setColor(kRed);

			return;
		}
	}
}


int CaloHitFrame::getColorBetweenMinAndMax(float min, float max, float value)
{
	return (51 + ( (value - min)*( 100 - 51 ) )/( max - min ) );
}

}

