  /// \file EventManager.cc
/*
 *
 * EventManager.cc source template automatically generated by a class generator
 * Creation date : lun. avr. 28 2014
 *
 * This file is part of SDHCALEventDisplay libraries.
 * 
 * SDHCALEventDisplay is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * SDHCALEventDisplay is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with SDHCALEventDisplay.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "EventManager.h"

// sdhcal
#include "EventNavigator.h"
#include "Config.h"
#include "CaloHit.h"
#include "Gui.h"
#include "LcioCollectionFrame.h"
#include "CaloHitHelper.h"

// lcio
#include "EVENT/LCEvent.h"
#include "EVENT/LCIO.h"
#include "EVENT/LCCollection.h"
#include "EVENT/CalorimeterHit.h"
#include "EVENT/SimCalorimeterHit.h"
#include "UTIL/CellIDDecoder.h"


// streamlog
#include "streamlog/streamlog.h"

// gear
#include "gear/GEAR.h"
#include "gearxml/GearXML.h"
#include "GearMgr.h"
#include "gear/CalorimeterParameters.h"
#include "gear/LayerLayout.h"

// root
#include "TEveBoxSet.h"
#include "TEveBox.h"
#include "TEveManager.h"
#include "TEveCompound.h"

extern TEveManager *gEve;

ClassImpQ(sdhcal::EventManager)

namespace sdhcal
{

//-------------------------------------------------------------------------------------------

EventManager::EventManager(EventNavigator *pEventNavigator)
{
	m_pEventNavigator = pEventNavigator;
	m_pEventNavigator->Connect("eventUpdated()", "sdhcal::EventManager", this, "loadCurrentEvent()");

	m_pEveCaloHitList = new TEveCompound();

	m_caloHitColorDisplay = SEMI_DIGITAL_THRESHOLD;
}

//-------------------------------------------------------------------------------------------

EventManager::~EventManager()
{
	delete m_pEveCaloHitList;
}

//-------------------------------------------------------------------------------------------

void EventManager::loadCurrentEvent()
{
	this->clear();
	EVENT::LCEvent *pLCEvent = m_pEventNavigator->getCurrentEvent();

	if(NULL != pLCEvent)
	{
		std::string sdhcalCollectionName = Gui::getInstance()->getLcioCollectionFrame()->getSDHCALCollectionName();

		delete m_pEveCaloHitList;
		m_pEveCaloHitList = new TEveCompound();
		m_pEveCaloHitList->SetName(sdhcalCollectionName.c_str());
		m_pEveCaloHitList->SetPickable(true);
		m_pEveCaloHitList->SetMainTransparency(100);

		try
		{
			EVENT::LCCollection *pCurrentCollection = pLCEvent->getCollection(sdhcalCollectionName);
			std::string collectionTypeName = pCurrentCollection->getTypeName();

			if(collectionTypeName == EVENT::LCIO::CALORIMETERHIT)
			{
				try
				{
					m_pEveCaloHitList->OpenCompound();
					this->loadCaloHitCollection(pCurrentCollection);
					m_pEveCaloHitList->CloseCompound();
					CaloHitHelper::CalculateCaloHitProperties(m_currentOrderedCaloHitList);
					gEve->AddElement(m_pEveCaloHitList);
					gEve->Redraw3D();
					this->caloHitsAvailable();
				}
				catch(EVENT::Exception &e)
				{
					streamlog_out(WARNING) << "Exception thrown while loading collection : " << sdhcalCollectionName << ". Message : " << e.what() << std::endl;
				}
			}
			// loadSimCaloHitCollection
			else if(collectionTypeName == EVENT::LCIO::SIMCALORIMETERHIT)
			{
				try
				{
					m_pEveCaloHitList->OpenCompound();
					this->loadSimCaloHitCollection(pCurrentCollection);
					m_pEveCaloHitList->CloseCompound();
					CaloHitHelper::CalculateCaloHitProperties(m_currentOrderedCaloHitList);
					gEve->AddElement(m_pEveCaloHitList);
					gEve->Redraw3D();
					this->caloHitsAvailable();
				}
				catch(EVENT::Exception &e)
				{
					streamlog_out(WARNING) << "Exception thrown while loading collection : " << sdhcalCollectionName << ". Message : " << e.what() << std::endl;
				}
			}
			else
				throw EVENT::Exception("SDHCAL collection type mismatch. Expected CALORIMETERHIT !");

		}
		catch(EVENT::Exception &e)
		{
			streamlog_out(WARNING) << "Couldn't load sdhcal collection " << sdhcalCollectionName << ". Message : " << e.what() << std::endl;
		}
		catch(gear::Exception &e)
		{
			streamlog_out(WARNING) << "Couldn't load sdhcal collection " << sdhcalCollectionName << ". GEAR message : " << e.what() << std::endl;
		}

	}
}

//-------------------------------------------------------------------------------------------

void EventManager::loadCaloHitCollection(EVENT::LCCollection *pCollection)
{
	if(LCIO::CALORIMETERHIT != pCollection->getTypeName())
			throw EVENT::Exception("Bad collection type while loading calorimeter hits");

		UTIL::CellIDDecoder<EVENT::CalorimeterHit> cellIDDecoder(pCollection);
		const std::string layerCodingString(pCollection->getParameters().getStringVal(LCIO::CellIDEncoding));

		std::string layerCoding;

		if(layerCodingString.empty())
		{
			layerCoding = "K-1";
		}
		else
		{
			layerCoding = (layerCodingString.find("K-1") == std::string::npos) ? "K" : "K-1";
		}

		std::string cellIDCodingI("I");
		std::string cellIDCodingJ("J");

		gear::GearMgr *pGearMgr = Config::getInstance()->getGearMgr();

		if(NULL == pGearMgr)
			throw EVENT::Exception("Gear file not parsed yet. Please parse the gear file before loading any collection !");

		const gear::CalorimeterParameters &calorimeterParameters = pGearMgr->getHcalEndcapParameters();
		const gear::LayerLayout &layerLayout = calorimeterParameters.getLayerLayout();
		unsigned int nLayers(layerLayout.getNLayers());

		float sdhcalThreshold1(static_cast<float>(calorimeterParameters.getDoubleVal("SemiDigitalThreshold1")));
		float sdhcalThreshold2(static_cast<float>(calorimeterParameters.getDoubleVal("SemiDigitalThreshold2")));
		float sdhcalThreshold3(static_cast<float>(calorimeterParameters.getDoubleVal("SemiDigitalThreshold3")));

		streamlog_out(MESSAGE) << "Loading calo hits size : " << pCollection->getNumberOfElements() << std::endl;

		for(unsigned int elt=0 ; elt<pCollection->getNumberOfElements() ; elt++)
		{
			EVENT::CalorimeterHit *pCaloHit = NULL;
			pCaloHit = dynamic_cast<EVENT::CalorimeterHit*>(pCollection->getElementAt(elt));

			if(NULL == pCaloHit)
				throw EVENT::Exception("Bad element type while loading calorimeter hits");

			CaloHitCell caloHitCell;
			caloHitCell.m_iCell   = cellIDDecoder(pCaloHit)[cellIDCodingI.c_str()];
			caloHitCell.m_jCell   = cellIDDecoder(pCaloHit)[cellIDCodingJ.c_str()];
			caloHitCell.m_layer   = cellIDDecoder(pCaloHit)[layerCoding.c_str()];

			if(caloHitCell.m_layer > nLayers-1)
				continue;

			caloHitCell.m_cellSize0 = layerLayout.getCellSize0(caloHitCell.m_layer);
			caloHitCell.m_cellSize1 = layerLayout.getCellSize1(caloHitCell.m_layer);
			caloHitCell.m_cellThickness = fabs(layerLayout.getThickness(caloHitCell.m_layer) - layerLayout.getAbsorberThickness(caloHitCell.m_layer));

			float layerThickness = layerLayout.getThickness(caloHitCell.m_layer);
			float absorberThickness = layerLayout.getAbsorberThickness(caloHitCell.m_layer);

			float posX = caloHitCell.m_iCell*caloHitCell.m_cellSize0 - 96*caloHitCell.m_cellSize0/2.0 - caloHitCell.m_cellSize0/2.0;
			float posY = caloHitCell.m_jCell*caloHitCell.m_cellSize1 - 96*caloHitCell.m_cellSize1/2.0 - caloHitCell.m_cellSize1/2.0;
			float posZ = caloHitCell.m_layer*layerThickness + absorberThickness + (layerThickness-absorberThickness)/2.0;

			CartesianVector caloHitPosition(posX, posY,	posZ);

			SemiDigitalThreshold threshold;

			if(sdhcalThreshold1 == pCaloHit->getEnergy())
				threshold = THRESHOLD_1;
			else if(sdhcalThreshold2 == pCaloHit->getEnergy())
				threshold = THRESHOLD_2;
			else if(sdhcalThreshold3 == pCaloHit->getEnergy())
				threshold = THRESHOLD_3;
			else
			{
				std::stringstream ss;
				ss << "While loading calo hit : semi digital threshold bad matching. Should be "
						"(" << sdhcalThreshold1 << "," << sdhcalThreshold2 << "" << sdhcalThreshold3 << ").";
				throw EVENT::Exception(ss.str());
			}

			CaloHit *pNewCaloHit = new CaloHit(caloHitPosition, caloHitCell, threshold);

			unsigned int color = this->getCaloHitColor(pNewCaloHit);
			pNewCaloHit->setColor(color);
			pNewCaloHit->setTransparency(0);

			m_currentCaloHitList.insert(pNewCaloHit);
			m_currentOrderedCaloHitList[pNewCaloHit->getCell().m_layer].insert(pNewCaloHit);
			m_pEveCaloHitList->AddElement(pNewCaloHit);
		}

		streamlog_out(MESSAGE) << "Calo hit collection of size "
				<< pCollection->getNumberOfElements()
				<< ", loaded with " << m_currentCaloHitList.size()
				<< " calo hits that fit into geometry" << std::endl;
}


void EventManager::loadSimCaloHitCollection(EVENT::LCCollection *pCollection)
{
	if(LCIO::SIMCALORIMETERHIT != pCollection->getTypeName())
			throw EVENT::Exception("Bad collection type while loading sim calorimeter hits");

		UTIL::CellIDDecoder<EVENT::SimCalorimeterHit> cellIDDecoder(pCollection);
		const std::string layerCodingString(pCollection->getParameters().getStringVal(LCIO::CellIDEncoding));

		std::string layerCoding;

		if(layerCodingString.empty())
		{
			layerCoding = "K-1";
		}
		else
		{
			layerCoding = (layerCodingString.find("K-1") == std::string::npos) ? "K" : "K-1";
		}

		std::string cellIDCodingI("I");
		std::string cellIDCodingJ("J");

		gear::GearMgr *pGearMgr = Config::getInstance()->getGearMgr();

		if(NULL == pGearMgr)
			throw EVENT::Exception("Gear file not parsed yet. Please parse the gear file before loading any collection !");

		const gear::CalorimeterParameters &calorimeterParameters = pGearMgr->getHcalEndcapParameters();
		const gear::LayerLayout &layerLayout = calorimeterParameters.getLayerLayout();
		unsigned int nLayers(layerLayout.getNLayers());

		int simThreshold1(calorimeterParameters.getIntVal("SimThreshold1"));
		int simThreshold2(calorimeterParameters.getIntVal("SimThreshold2"));
		int simThreshold3(calorimeterParameters.getIntVal("SimThreshold3"));

		streamlog_out(MESSAGE) << "Loading sim calo hits size : " << pCollection->getNumberOfElements() << std::endl;

		for(unsigned int elt=0 ; elt<pCollection->getNumberOfElements() ; elt++)
		{
			EVENT::SimCalorimeterHit *pCaloHit = NULL;
			pCaloHit = dynamic_cast<EVENT::SimCalorimeterHit*>(pCollection->getElementAt(elt));

			if(NULL == pCaloHit)
				throw EVENT::Exception("Bad element type while loading sim calorimeter hits");

			CaloHitCell caloHitCell;
			caloHitCell.m_iCell   = cellIDDecoder(pCaloHit)[cellIDCodingI.c_str()];
			caloHitCell.m_jCell   = cellIDDecoder(pCaloHit)[cellIDCodingJ.c_str()];
			caloHitCell.m_layer   = cellIDDecoder(pCaloHit)[layerCoding.c_str()];

			if(caloHitCell.m_layer > nLayers-1)
				continue;

			caloHitCell.m_cellSize0 = layerLayout.getCellSize0(caloHitCell.m_layer);
			caloHitCell.m_cellSize1 = layerLayout.getCellSize1(caloHitCell.m_layer);
			caloHitCell.m_cellThickness = fabs(layerLayout.getThickness(caloHitCell.m_layer) - layerLayout.getAbsorberThickness(caloHitCell.m_layer));

			float layerThickness = layerLayout.getThickness(caloHitCell.m_layer);
			float absorberThickness = layerLayout.getAbsorberThickness(caloHitCell.m_layer);

			float posX = caloHitCell.m_iCell*caloHitCell.m_cellSize0 - 96*caloHitCell.m_cellSize0/2.0 - caloHitCell.m_cellSize0/2.0;
			float posY = caloHitCell.m_jCell*caloHitCell.m_cellSize1 - 96*caloHitCell.m_cellSize1/2.0 - caloHitCell.m_cellSize1/2.0;
			float posZ = caloHitCell.m_layer*layerThickness + absorberThickness + (layerThickness-absorberThickness)/2.0;

			CartesianVector caloHitPosition(posX, posY,	posZ);

			SemiDigitalThreshold threshold;

			if(pCaloHit->getNMCContributions() > simThreshold3)
				threshold = THRESHOLD_3;
			else if(pCaloHit->getNMCContributions() > simThreshold2)
				threshold = THRESHOLD_2;
			else if(pCaloHit->getNMCContributions() > simThreshold1)
				threshold = THRESHOLD_1;
			else
				continue;

			CaloHit *pNewCaloHit = new CaloHit(caloHitPosition, caloHitCell, threshold);

			unsigned int color = this->getCaloHitColor(pNewCaloHit);
			pNewCaloHit->setColor(color);
			pNewCaloHit->setTransparency(0);

			m_currentCaloHitList.insert(pNewCaloHit);
			m_currentOrderedCaloHitList[pNewCaloHit->getCell().m_layer].insert(pNewCaloHit);
			m_pEveCaloHitList->AddElement(pNewCaloHit);
		}

		streamlog_out(MESSAGE) << "Sim calo hit collection of size "
				<< pCollection->getNumberOfElements()
				<< ", loaded with " << m_currentCaloHitList.size()
				<< " passing threshold1 of " << simThreshold1 << " MC contributions" << std::endl;
}

//-------------------------------------------------------------------------------------------

unsigned int EventManager::getCaloHitColor(CaloHit *pCaloHit)
{
	switch(m_caloHitColorDisplay)
	{
		case GRAY_UNIFORM:
		{
			return kGray+1;
		}
		case SEMI_DIGITAL_THRESHOLD:
		{
			if(THRESHOLD_1 == pCaloHit->getSemiDigitalThreshold())
				return kGreen;
			if(THRESHOLD_2 == pCaloHit->getSemiDigitalThreshold())
				return kBlue;
			if(THRESHOLD_3 == pCaloHit->getSemiDigitalThreshold())
				return kRed;
		}
		default:
			return kGray+1;
	}
}

//-------------------------------------------------------------------------------------------

void EventManager::clear()
{
	for(CaloHitList::iterator iter = m_currentCaloHitList.begin() , endIter = m_currentCaloHitList.end() ; endIter != iter ; ++iter)
	{
		CaloHit *pCaloHit = *iter;
		delete pCaloHit;
	}

	m_pEveCaloHitList->RemoveElements();

	m_currentCaloHitList.clear();
	m_currentOrderedCaloHitList.clear();
}



void EventManager::caloHitsAvailable()
{
	Emit("caloHitsAvailable()");
}

} 

